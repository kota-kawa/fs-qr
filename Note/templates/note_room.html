{% extends "note_layout.html" %}

{% block meta_robots %}noindex, nofollow{% endblock %}
{% block meta_googlebot %}noindex, nofollow{% endblock %}

{% block page_title %}ノートルーム {{ room_id }} | FS!QR Note - リアルタイム共同編集{% endblock %}

{% block meta_description %}FS!QR Noteのリアルタイム共同編集ノートルーム。複数人でオンラインノートを同時編集・共有。リアルタイムでテキストが同期される協業ノートツール。{% endblock %}

{% block meta_keywords %}ノートルーム, リアルタイム共同編集, オンラインノート, 同時編集, 協業ツール, 共有ノート, FS QR Note{% endblock %}

{% block og_title %}ノートルーム {{ room_id }} | FS!QR Note - リアルタイム共同編集{% endblock %}

{% block og_description %}FS!QR Noteのリアルタイム共同編集ノートルーム。複数人でオンラインノートを同時編集・共有。リアルタイムでテキストが同期される協業ノートツール。{% endblock %}

{% block twitter_title %}ノートルーム {{ room_id }} | FS!QR Note{% endblock %}

{% block twitter_description %}リアルタイム共同編集ノートルーム。複数人でオンラインノートを同時編集・共有できます。{% endblock %}

{% block contents %}

<style>
/* Override colors for Note room to match create/search pages */
.modern-card-header {
  --modern-card-header-gradient: linear-gradient(135deg, rgb(132, 204, 22) 0%, rgb(163, 230, 53) 100%);
  --modern-card-header-accent: rgb(163, 230, 53);
}

.room-info-card {
  --room-info-header-gradient: linear-gradient(135deg, rgb(132, 204, 22) 0%, rgb(163, 230, 53) 100%);
}

.usage-section {
  --usage-header-gradient: linear-gradient(135deg, rgb(132, 204, 22) 0%, rgb(163, 230, 53) 100%);
  --usage-header-accent: rgb(163, 230, 53);
}

.room-info-value.room-info-url {
  display: inline-flex;
  align-items: center;
  gap: 0.75rem;
  flex-wrap: wrap;
}

.room-info-url-link {
  color: inherit;
  text-decoration: none;
  word-break: break-all;
}

.room-info-url-link:hover,
.room-info-url-link:focus {
  color: inherit;
  text-decoration: none;
}

.copy-url-button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 2.5rem;
  height: 2.5rem;
  padding: 0;
  border-radius: 999px;
  border: none;
  background: linear-gradient(135deg, rgb(132, 204, 22) 0%, rgb(163, 230, 53) 100%);
  color: #fff;
  cursor: pointer;
  transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
}

.copy-url-button svg {
  width: 1.25rem;
  height: 1.25rem;
  flex: none;
}

.copy-url-button:hover,
.copy-url-button:focus-visible {
  transform: translateY(-1px);
  box-shadow: 0 10px 15px -8px rgba(132, 204, 22, 0.5);
}

.copy-url-button:active {
  transform: translateY(0);
}

.copy-url-button.copied {
  background: linear-gradient(135deg, #15803d 0%, #22c55e 100%);
}
</style>

<div class="modern-page-container">
    <div class="modern-content-card">
        <div class="modern-card-header">
            <h1>
                <span class="svg-icon svg-icon--xl svg-icon--with-text" aria-hidden="true">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                        <path fill-rule="evenodd" d="M5.625 1.5c-1.036 0-1.875.84-1.875 1.875v17.25c0 1.035.84 1.875 1.875 1.875h12.75c1.035 0 1.875-.84 1.875-1.875V12.75A3.75 3.75 0 0 0 16.5 9h-1.875a1.875 1.875 0 0 1-1.875-1.875V5.25A3.75 3.75 0 0 0 9 1.5H5.625ZM7.5 15a.75.75 0 0 1 .75-.75h7.5a.75.75 0 0 1 0 1.5h-7.5A.75.75 0 0 1 7.5 15Zm.75 2.25a.75.75 0 0 0 0 1.5H12a.75.75 0 0 0 0-1.5H8.25Z" clip-rule="evenodd"/>
                        <path d="M12.971 1.816A5.23 5.23 0 0 1 14.25 5.25v1.875c0 .207.168.375.375.375H16.5a5.23 5.23 0 0 1 3.434 1.279 9.768 9.768 0 0 0-6.963-6.963Z"/>
                    </svg>
                </span>
                リアルタイムノート
            </h1>
        </div>
        
        <div class="modern-card-body">
            <!-- Room Info + QR Code -->
            <div class="room-info-container">
                <div class="room-info-card">
                    <div class="room-info-header">Room情報</div>
                    <div class="room-info-body">
                        <div class="room-info-row">
                            <span class="room-info-label">Room ID</span>
                            <span class="room-info-value">{{ room_id }}</span>
                        </div>
                        <div class="room-info-row">
                            <span class="room-info-label">Password</span>
                            <span class="room-info-value">{{ password }}</span>
                        </div>
                        <div class="room-info-row">
                            <span class="room-info-label">URL</span>
                            <span class="room-info-value room-info-url">
                                <a id="noteRoomUrl" class="room-info-url-link" href="{{ url_for('note.note_room', room_id=room_id, password=password, _external=True) }}" target="_blank" rel="noopener">
                                    {{ url_for('note.note_room', room_id=room_id, password=password, _external=True) }}
                                </a>
                                <button
                                  type="button"
                                  class="copy-url-button"
                                  data-copy-target="noteRoomUrl"
                                  data-default-label="URLをコピー"
                                  data-copied-label="コピー済み"
                                  aria-label="URLをコピー"
                                  title="URLをコピー"
                                >
                                  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-hidden="true">
                                    <path fill="currentColor" d="M16 1H4a2 2 0 0 0-2 2v12h2V3h12V1Zm4 4H8a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2Zm0 16H8V7h12v14Z"/>
                                  </svg>
                                </button>
                            </span>
                        </div>
                        <div class="room-info-row">
                            <span class="room-info-label">削除予定日</span>
                            <span class="room-info-value">
                                {% if deletion_date %}
                                    {{ deletion_date }} （{{ retention_days }}日後）
                                {% else %}
                                    {{ retention_days }}日後に自動削除
                                {% endif %}
                            </span>
                        </div>
                    </div>
                </div>
                
                <div class="qr-code-container">
                    <img src="https://api.qrserver.com/v1/create-qr-code?size=200x200&data={{ url_for('note.note_room', room_id=room_id, password=password, _external=True)|urlencode }}"
                         alt="QR Code" style="width: 160px; height: 160px;">
                </div>
            </div>

            <!-- Editor -->
            <div class="modern-form-group">
                <label for="editor" class="modern-form-label">共有ノート（最大10000文字）</label>
                <textarea id="editor" class="modern-editor"
                          placeholder="ここに入力すると1秒ごとに同期されます…"
                          maxlength="10000" style="height: 60vh;"></textarea>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 0.5rem;">
                    <small style="color: var(--text-medium);">リアルタイムで同期・保存されます</small>
                    <span id="status" class="badge bg-secondary" style="padding: 0.5rem 1rem; border-radius: 20px;">Syncing…</span>
                </div>
            </div>
        </div>
    </div>


<div class="usage-section">
  <div class="usage-section-header">
    <h5>使い方</h5>
  </div>
  <div class="usage-section-content">
    <p>
      このルームではテキストをリアルタイムに共有できます。<br>
      上記のIDとパスワード、URL、またはQRコードを共有すると他の参加者も同じノートを編集できます。<br>
      エディタに入力すると1秒ごとに自動保存・同期され、変更はすぐに反映されます。<br>
      最大10000文字まで入力可能です。
    </p>
  </div>
</div>

<script>
  async function copyTextToClipboard(text) {
    if (navigator.clipboard && window.isSecureContext) {
      return navigator.clipboard.writeText(text);
    }

    return new Promise((resolve, reject) => {
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.style.position = 'fixed';
      textarea.style.opacity = '0';
      document.body.appendChild(textarea);
      textarea.focus();
      textarea.select();

      try {
        if (document.execCommand('copy')) {
          resolve();
        } else {
          reject(new Error('execCommand failed'));
        }
      } catch (err) {
        reject(err);
      } finally {
        document.body.removeChild(textarea);
      }
    });
  }

  document.addEventListener('DOMContentLoaded', function () {
    document.querySelectorAll('.copy-url-button').forEach((button) => {
      button.addEventListener('click', async () => {
        const targetId = button.getAttribute('data-copy-target');
        const target = targetId ? document.getElementById(targetId) : null;
        if (!target) {
          return;
        }

        const text = target.textContent.trim();
        const defaultLabel = button.getAttribute('data-default-label') || 'コピー';
        const copiedLabel = button.getAttribute('data-copied-label') || 'コピー済み';
        if (!button.hasAttribute('aria-label')) {
          button.setAttribute('aria-label', defaultLabel);
        }
        if (!button.hasAttribute('title')) {
          button.setAttribute('title', defaultLabel);
        }

        try {
          await copyTextToClipboard(text);
          button.classList.add('copied');
          button.setAttribute('aria-label', copiedLabel);
          button.setAttribute('title', copiedLabel);
          setTimeout(() => {
            button.classList.remove('copied');
            button.setAttribute('aria-label', defaultLabel);
            button.setAttribute('title', defaultLabel);
          }, 2000);
        } catch (error) {
          alert('コピーに失敗しました。URLを選択して手動でコピーしてください。');
        }
      });
    });
  });
</script>
<script>
  const room   = "{{ room_id }}";
  const roomPassword = "{{ password }}";
  const editor = document.getElementById("editor");
  const status = document.getElementById("status");
  let lastStamp = "", selfEdit = false;
  let contentAtLastSync = "";  // <--- 追加: 最後に同期した時点のコンテンツ
  let selfEditTimeout = null; // selfEdit フラグのタイムアウト管理

  /* 最大文字数（サーバー側と合わせること） */
  const MAX_LENGTH = 10000;  // 追加: フロント側の最大文字数
  
  // selfEdit フラグの安全な設定関数
  function setSelfEdit(value, timeoutMs = 8000) {
    selfEdit = value;
    
    if (selfEditTimeout) {
      clearTimeout(selfEditTimeout);
      selfEditTimeout = null;
    }
    
    if (value && timeoutMs > 0) {
      // selfEdit が長時間 true のままにならないよう安全装置
      selfEditTimeout = setTimeout(() => {
        if (selfEdit) {
          console.warn("selfEdit flag was stuck, resetting");
          selfEdit = false;
          status.className = "badge bg-warning";
          status.textContent = "Connection timeout";
        }
      }, timeoutMs);
    }
  }

  // カーソル位置が安全に復元できるかチェックする関数
  function isCursorSafeToRestore(oldContent, newContent, cursorStart, cursorEnd) {
    // 基本的な安全チェック
    if (cursorStart < 0 || cursorEnd < 0 || cursorStart > cursorEnd) {
      return false;
    }
    
    // コンテンツの長さが大幅に変わった場合は復元しない
    const lengthDiff = Math.abs(newContent.length - oldContent.length);
    const relativeDiff = lengthDiff / Math.max(oldContent.length, 1);
    if (relativeDiff > 0.3) { // 30%以上の変化は復元しない
      return false;
    }
    
    // カーソル周辺のコンテンツが変更されているかチェック
    const contextRange = 50; // カーソル前後50文字の範囲をチェック
    const contextStart = Math.max(0, cursorStart - contextRange);
    const contextEnd = Math.min(oldContent.length, cursorEnd + contextRange);
    
    const oldContext = oldContent.substring(contextStart, contextEnd);
    const newContextEnd = Math.min(newContent.length, contextEnd);
    const newContext = newContent.substring(contextStart, newContextEnd);
    
    // コンテキストが大幅に変更されている場合は復元しない
    return oldContext === newContext || lengthDiff < 10;
  }

  let ws = null;
  let reconnectAttempt = 0;
  let reconnectTimer = null;
  let pendingContent = null;

  function setStatus(className, text) {
    status.className = className;
    status.textContent = text;
  }

  /* 入力→WebSocket送信(800ms) */
  let typTimer;
  
  function sendSave(currentContent) {
    // 文字数チェック
    if (currentContent.length > MAX_LENGTH) {
      alert(`文字数は最大 ${MAX_LENGTH} 文字までです。現在 ${currentContent.length} 文字です。`);
      setSelfEdit(false);
      return;
    }

    // 変更がない場合は保存をスキップ
    if (currentContent === contentAtLastSync) {
      setSelfEdit(false);
      return;
    }

    pendingContent = currentContent;
    if (!ws || ws.readyState !== WebSocket.OPEN) {
      setStatus("badge bg-warning text-dark", "Offline (reconnecting...)");
      return;
    }

    pendingContent = null;
    setSelfEdit(true, 12000);
    setStatus("badge bg-secondary", "Saving...");

    ws.send(JSON.stringify({
      type: "save",
      content: currentContent,
      last_known_updated_at: lastStamp,
      original_content: contentAtLastSync
    }));
  }

  editor.addEventListener("input", () => {
    clearTimeout(typTimer);
    
    typTimer = setTimeout(() => {
      const currentContent = editor.value;
      sendSave(currentContent);
    }, 800); // デバウンス時間を800msに延長（競合を更に削減）
  });

  function applyServerContent(newContent, updatedAt, message) {
    if (newContent === undefined || updatedAt === undefined) {
      return;
    }

    const isEditorFocused = document.activeElement === editor;
    const oldContent = editor.value;
    let cursorStart = 0;
    let cursorEnd = 0;

    if (isEditorFocused) {
      cursorStart = editor.selectionStart;
      cursorEnd = editor.selectionEnd;
    }

    editor.value = newContent;

    if (isEditorFocused && isCursorSafeToRestore(oldContent, newContent, cursorStart, cursorEnd)) {
      const newLength = newContent.length;
      editor.setSelectionRange(Math.min(cursorStart, newLength), Math.min(cursorEnd, newLength));
      editor.focus();
    }

    lastStamp = updatedAt;
    contentAtLastSync = newContent;

    if (message) {
      setStatus("badge bg-warning text-dark", message);
    }
  }

  function handleAck(payload) {
    if (payload.status && (payload.status.startsWith("ok") || payload.status.startsWith("conflict"))) {
      if (payload.content !== undefined && payload.updated_at) {
        applyServerContent(payload.content, payload.updated_at);
      }

      if (payload.status === "ok_merged") {
        setStatus("badge bg-info", "Saved (Merged)");
      } else if (payload.status.startsWith("conflict")) {
        setStatus("badge bg-warning text-dark", "Conflict resolved");
      } else {
        setStatus("badge bg-success", "Saved");
      }
    } else if (payload.error) {
      setStatus("badge bg-danger", payload.error);
    }
    setSelfEdit(false);
  }

  function handleUpdate(payload) {
    if (selfEdit) {
      return;
    }
    if (payload.updated_at && payload.updated_at !== lastStamp) {
      applyServerContent(payload.content, payload.updated_at, "Updated by others");
    }
  }

  function handleInit(payload) {
    editor.value = payload.content || "";
    contentAtLastSync = editor.value;
    lastStamp = payload.updated_at || "";
    setStatus("badge bg-success", "Up-to-date");
  }

  function scheduleReconnect() {
    if (reconnectTimer) {
      return;
    }
    const delay = Math.min(500 * Math.pow(2, reconnectAttempt), 5000);
    reconnectAttempt += 1;
    setStatus("badge bg-warning text-dark", "Reconnecting...");
    reconnectTimer = setTimeout(() => {
      reconnectTimer = null;
      connectWebSocket();
    }, delay);
  }

  function connectWebSocket() {
    const proto = window.location.protocol === "https:" ? "wss" : "ws";
    ws = new WebSocket(`${proto}://${window.location.host}/ws/note/${room}/${roomPassword}`);

    ws.addEventListener("open", () => {
      reconnectAttempt = 0;
      setStatus("badge bg-info", "Connected");
      if (pendingContent !== null) {
        const content = pendingContent;
        pendingContent = null;
        sendSave(content);
      }
    });

    ws.addEventListener("message", event => {
      let payload = null;
      try {
        payload = JSON.parse(event.data);
      } catch (err) {
        return;
      }
      if (!payload || !payload.type) {
        return;
      }
      if (payload.type === "init") {
        handleInit(payload);
        return;
      }
      if (payload.type === "ack") {
        handleAck(payload);
        return;
      }
      if (payload.type === "update") {
        handleUpdate(payload);
        return;
      }
      if (payload.type === "error") {
        setStatus("badge bg-danger", payload.error || "Connection error");
      }
    });

    ws.addEventListener("close", (event) => {
      console.warn("WebSocket closed:", event.code, event.reason);
      if (event.code === 1006) {
         console.error("WebSocket connection failed abruptly. Check server logs or network.");
      }
      scheduleReconnect();
    });

    ws.addEventListener("error", () => {
      setStatus("badge bg-danger", "Connection error");
    });
  }

  connectWebSocket();
</script>
{% endblock %}
