{% extends "note_layout.html" %}

{% block page_title %}ãƒãƒ¼ãƒˆãƒ«ãƒ¼ãƒ  {{ room_id }} | FS!QR Note - ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å…±åŒç·¨é›†{% endblock %}

{% block meta_description %}FS!QR Noteã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å…±åŒç·¨é›†ãƒãƒ¼ãƒˆãƒ«ãƒ¼ãƒ ã€‚è¤‡æ•°äººã§ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’åŒæ™‚ç·¨é›†ãƒ»å…±æœ‰ã€‚ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§ãƒ†ã‚­ã‚¹ãƒˆãŒåŒæœŸã•ã‚Œã‚‹å”æ¥­ãƒãƒ¼ãƒˆãƒ„ãƒ¼ãƒ«ã€‚{% endblock %}

{% block meta_keywords %}ãƒãƒ¼ãƒˆãƒ«ãƒ¼ãƒ , ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å…±åŒç·¨é›†, ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒãƒ¼ãƒˆ, åŒæ™‚ç·¨é›†, å”æ¥­ãƒ„ãƒ¼ãƒ«, å…±æœ‰ãƒãƒ¼ãƒˆ, FS QR Note{% endblock %}

{% block og_title %}ãƒãƒ¼ãƒˆãƒ«ãƒ¼ãƒ  {{ room_id }} | FS!QR Note - ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å…±åŒç·¨é›†{% endblock %}

{% block og_description %}FS!QR Noteã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å…±åŒç·¨é›†ãƒãƒ¼ãƒˆãƒ«ãƒ¼ãƒ ã€‚è¤‡æ•°äººã§ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’åŒæ™‚ç·¨é›†ãƒ»å…±æœ‰ã€‚ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§ãƒ†ã‚­ã‚¹ãƒˆãŒåŒæœŸã•ã‚Œã‚‹å”æ¥­ãƒãƒ¼ãƒˆãƒ„ãƒ¼ãƒ«ã€‚{% endblock %}

{% block twitter_title %}ãƒãƒ¼ãƒˆãƒ«ãƒ¼ãƒ  {{ room_id }} | FS!QR Note{% endblock %}

{% block twitter_description %}ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å…±åŒç·¨é›†ãƒãƒ¼ãƒˆãƒ«ãƒ¼ãƒ ã€‚è¤‡æ•°äººã§ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’åŒæ™‚ç·¨é›†ãƒ»å…±æœ‰ã§ãã¾ã™ã€‚{% endblock %}

{% block contents %}

<style>
/* Override colors for Note room to match create/search pages */
.modern-card-header {
  background: linear-gradient(135deg, rgb(132, 204, 22) 0%, rgb(163, 230, 53) 100%) !important;
}

.room-info-header {
  background: linear-gradient(135deg, rgb(132, 204, 22) 0%, rgb(163, 230, 53) 100%) !important;
}

.usage-section-header {
  background: linear-gradient(135deg, rgb(132, 204, 22) 0%, rgb(163, 230, 53) 100%) !important;
}

.usage-section-header::after {
  border-top-color: rgb(163, 230, 53) !important;
}
</style>

<div class="modern-page-container">
    <div class="modern-content-card">
        <div class="modern-card-header">
            <h1>ğŸ“ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒãƒ¼ãƒˆ</h1>
        </div>
        
        <div class="modern-card-body">
            <!-- Room Info + QR Code -->
            <div class="room-info-container">
                <div class="room-info-card">
                    <div class="room-info-header">Roomæƒ…å ±</div>
                    <div class="room-info-body">
                        <div class="room-info-row">
                            <span class="room-info-label">Room ID</span>
                            <span class="room-info-value">{{ room_id }}</span>
                        </div>
                        <div class="room-info-row">
                            <span class="room-info-label">Password</span>
                            <span class="room-info-value">{{ password }}</span>
                        </div>
                    </div>
                </div>
                
                <div class="qr-code-container">
                    <img src="https://api.qrserver.com/v1/create-qr-code?size=200x200&data={{ url_for('note.note_direct_access', room_id=room_id, password=password, _external=True)|urlencode }}"
                         alt="QR Code" style="width: 160px; height: 160px;">
                </div>
            </div>

            <!-- Editor -->
            <div class="modern-form-group">
                <label for="editor" class="modern-form-label">å…±æœ‰ãƒãƒ¼ãƒˆï¼ˆæœ€å¤§5000æ–‡å­—ï¼‰</label>
                <textarea id="editor" class="modern-editor"
                          placeholder="ã“ã“ã«å…¥åŠ›ã™ã‚‹ã¨1ç§’ã”ã¨ã«åŒæœŸã•ã‚Œã¾ã™â€¦"
                          maxlength="5000" style="height: 60vh;"></textarea>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 0.5rem;">
                    <small style="color: var(--text-medium);">ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§åŒæœŸãƒ»ä¿å­˜ã•ã‚Œã¾ã™</small>
                    <span id="status" class="badge bg-secondary" style="padding: 0.5rem 1rem; border-radius: 20px;">Syncingâ€¦</span>
                </div>
            </div>
        </div>
    </div>


<div class="usage-section">
  <div class="usage-section-header">
    <h5>ä½¿ã„æ–¹</h5>
  </div>
  <div class="usage-section-content">
    <p>
      ã“ã®ãƒ«ãƒ¼ãƒ ã§ã¯ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã«å…±æœ‰ã§ãã¾ã™ã€‚<br>
      ä¸Šè¨˜ã®IDã¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã€ã¾ãŸã¯QRã‚³ãƒ¼ãƒ‰ã‚’å…±æœ‰ã™ã‚‹ã¨ä»–ã®å‚åŠ è€…ã‚‚åŒã˜ãƒãƒ¼ãƒˆã‚’ç·¨é›†ã§ãã¾ã™ã€‚<br>
      ã‚¨ãƒ‡ã‚£ã‚¿ã«å…¥åŠ›ã™ã‚‹ã¨1ç§’ã”ã¨ã«è‡ªå‹•ä¿å­˜ãƒ»åŒæœŸã•ã‚Œã€å¤‰æ›´ã¯ã™ãã«åæ˜ ã•ã‚Œã¾ã™ã€‚<br>
      æœ€å¤§5000æ–‡å­—ã¾ã§å…¥åŠ›å¯èƒ½ã§ã™ã€‚
    </p>
  </div>
</div>

<script>
  const room   = "{{ room_id }}";
  const editor = document.getElementById("editor");
  const status = document.getElementById("status");
  let lastStamp = "", selfEdit = false;
  let contentAtLastSync = "";  // <--- è¿½åŠ : æœ€å¾Œã«åŒæœŸã—ãŸæ™‚ç‚¹ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„
  let selfEditTimeout = null; // selfEdit ãƒ•ãƒ©ã‚°ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆç®¡ç†

  /* æœ€å¤§æ–‡å­—æ•°ï¼ˆã‚µãƒ¼ãƒãƒ¼å´ã¨åˆã‚ã›ã‚‹ã“ã¨ï¼‰ */
  const MAX_LENGTH = 5000;  // è¿½åŠ : ãƒ•ãƒ­ãƒ³ãƒˆå´ã®æœ€å¤§æ–‡å­—æ•°
  
  // selfEdit ãƒ•ãƒ©ã‚°ã®å®‰å…¨ãªè¨­å®šé–¢æ•°
  function setSelfEdit(value, timeoutMs = 10000) {
    selfEdit = value;
    
    if (selfEditTimeout) {
      clearTimeout(selfEditTimeout);
      selfEditTimeout = null;
    }
    
    if (value && timeoutMs > 0) {
      // selfEdit ãŒé•·æ™‚é–“ true ã®ã¾ã¾ã«ãªã‚‰ãªã„ã‚ˆã†å®‰å…¨è£…ç½®
      selfEditTimeout = setTimeout(() => {
        if (selfEdit) {
          console.warn("selfEdit flag was stuck, resetting");
          selfEdit = false;
          status.className = "badge bg-warning";
          status.textContent = "Connection timeout";
        }
      }, timeoutMs);
    }
  }

  /* åˆå›ãƒ­ãƒ¼ãƒ‰ */
  fetch(`/api/note/${room}`).then(r => r.json()).then(j => {
    editor.value = j.content;
    contentAtLastSync = j.content;  // <--- è¿½åŠ 
    lastStamp = j.updated_at;
    status.className = "badge bg-success";
    status.textContent = "Up-to-date";
  });

  /* å…¥åŠ›â†’POST(500ms) - æ”¹å–„: ãƒ‡ãƒã‚¦ãƒ³ã‚¹æ™‚é–“ã‚’å»¶é•·ã—ã¦ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆå‰Šæ¸› */
  let typTimer;
  let saveRetryTimer;
  let retryCount = 0;
  const MAX_RETRIES = 3;
  
  // ä¿å­˜å‡¦ç†ã‚’å®Ÿè¡Œã™ã‚‹é–¢æ•°ï¼ˆãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½ä»˜ãï¼‰
  function performSave(currentContent, isRetry = false) {
    // æ–‡å­—æ•°ãƒã‚§ãƒƒã‚¯
    if (currentContent.length > MAX_LENGTH) {
      alert(`æ–‡å­—æ•°ã¯æœ€å¤§ ${MAX_LENGTH} æ–‡å­—ã¾ã§ã§ã™ã€‚ç¾åœ¨ ${currentContent.length} æ–‡å­—ã§ã™ã€‚`);
      setSelfEdit(false);
      return;
    }

    if (!isRetry) {
      retryCount = 0;
      setSelfEdit(true, 15000); // 15ç§’ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®š
      status.className = "badge bg-secondary";
      status.textContent = "Saving...";
    }

    fetch(`/api/note/${room}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        content: currentContent,
        last_known_updated_at: lastStamp,
        original_content: contentAtLastSync
      })
    })
    .then(r => {
      if (!r.ok) {
        return r.json().then(err => {
          throw new Error(err.error || "Save error");
        });
      }
      return r.json();
    })
    .then(j => {
      retryCount = 0; // æˆåŠŸã—ãŸã‚‰ãƒªãƒˆãƒ©ã‚¤ã‚«ã‚¦ãƒ³ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
      
      if (j.status && (j.status.startsWith("ok") || j.status.startsWith("conflict"))) {
        lastStamp = j.updated_at;
        if (j.content !== undefined && editor.value !== j.content) {
          // ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰æ–°ã—ã„ã‚³ãƒ³ãƒ†ãƒ³ãƒˆãŒè¿”ã•ã‚ŒãŸå ´åˆã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ä¿æŒå‡¦ç†
          const cursorStart = editor.selectionStart;
          const cursorEnd = editor.selectionEnd;
          const isEditorFocused = document.activeElement === editor;
          
          editor.value = j.content;
          
          // ã‚¨ãƒ‡ã‚£ã‚¿ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ãŒã‚ã‚‹å ´åˆã®ã¿ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’å¾©å…ƒ
          if (isEditorFocused) {
            const newLength = j.content.length;
            const adjustedStart = Math.min(cursorStart, newLength);
            const adjustedEnd = Math.min(cursorEnd, newLength);
            editor.setSelectionRange(adjustedStart, adjustedEnd);
          }
        }
        contentAtLastSync = editor.value;
        
        status.className = "badge bg-success";
        status.textContent = "Saved";
        if (j.status === "ok_merged") {
          status.className = "badge bg-info";
          status.textContent = "Saved (Merged)";
        } else if (j.status === "conflict_merge_failed" || j.status === "conflict_during_merge_save" || j.status === "conflict") {
          status.className = "badge bg-warning text-dark";
          status.textContent = "Conflict resolved";
        }
      } else if (j.error) {
        status.className = "badge bg-danger";
        status.textContent = j.error;
      }
      setSelfEdit(false);
    })
    .catch(err => {
      // ã‚¨ãƒ©ãƒ¼æ™‚ã®ãƒªãƒˆãƒ©ã‚¤å‡¦ç†
      if (retryCount < MAX_RETRIES && !err.message.includes("exceeds max length")) {
        retryCount++;
        status.className = "badge bg-warning";
        status.textContent = `Retrying... (${retryCount}/${MAX_RETRIES})`;
        
        // æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ã§ãƒªãƒˆãƒ©ã‚¤
        const retryDelay = Math.min(1000 * Math.pow(2, retryCount - 1), 5000);
        saveRetryTimer = setTimeout(() => {
          performSave(currentContent, true);
        }, retryDelay);
      } else {
        status.className = "badge bg-danger";
        status.textContent = err.message || "Save failed";
        setSelfEdit(false);
      }
    });
  }

  editor.addEventListener("input", () => {
    clearTimeout(typTimer);
    clearTimeout(saveRetryTimer); // æ—¢å­˜ã®ãƒªãƒˆãƒ©ã‚¤ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
    
    typTimer = setTimeout(() => {
      const currentContent = editor.value;
      performSave(currentContent);
    }, 500); // 500msã«å»¶é•·
  });

  /* é©å¿œçš„ãƒãƒ¼ãƒªãƒ³ã‚° - ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ç·¨é›†ä¸­ã¯é »åº¦ã‚’ä¸‹ã’ã‚‹ */
  let lastActivity = Date.now();
  let pollingInterval = 1000; // åŸºæœ¬ãƒãƒ¼ãƒªãƒ³ã‚°é–“éš”
  let lastPollingTime = Date.now();
  
  // ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£æ¤œå‡ºã®ãŸã‚ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
  editor.addEventListener("focus", () => {
    lastActivity = Date.now();
  });
  
  editor.addEventListener("keydown", () => {
    lastActivity = Date.now();
  });
  
  function adaptivePolling() {
    const now = Date.now();
    const timeSinceActivity = now - lastActivity;
    const timeSinceLastPoll = now - lastPollingTime;
    
    // æœ€è¿‘ç·¨é›†æ´»å‹•ãŒã‚ã£ãŸå ´åˆã¯ãƒãƒ¼ãƒªãƒ³ã‚°é »åº¦ã‚’ä¸‹ã’ã‚‹
    if (timeSinceActivity < 5000) { // 5ç§’ä»¥å†…ã«æ´»å‹•ãŒã‚ã£ãŸ
      pollingInterval = 2000; // 2ç§’é–“éš”
    } else {
      pollingInterval = 1000; // é€šå¸¸ã®1ç§’é–“éš”
    }
    
    // ãƒãƒ¼ãƒªãƒ³ã‚°å®Ÿè¡Œã®åˆ¤å®š
    if (timeSinceLastPoll >= pollingInterval) {
      lastPollingTime = now;
      performPolling();
    }
    
    // æ¬¡å›ãƒãƒ¼ãƒªãƒ³ã‚°äºˆç´„ï¼ˆ100msé–“éš”ã§ãƒã‚§ãƒƒã‚¯ï¼‰
    setTimeout(adaptivePolling, 100);
  }
  
  function performPolling() {
    if (selfEdit) return; // è‡ªåˆ†ç·¨é›†ä¸­ã¯ãƒãƒ¼ãƒªãƒ³ã‚°ã—ãªã„
    
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒç¾åœ¨ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã—ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    const isEditorFocused = document.activeElement === editor;
    
    fetch(`/api/note/${room}`)
      .then(r => r.json())
      .then(j => {
        if (j.updated_at !== lastStamp) {
          if (!selfEdit) {
            // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã—ã¦ã„ã‚‹å ´åˆã€ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’ä¿å­˜
            let cursorStart = 0;
            let cursorEnd = 0;
            if (isEditorFocused) {
              cursorStart = editor.selectionStart;
              cursorEnd = editor.selectionEnd;
            }
            
            // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’æ›´æ–°
            editor.value = j.content;
            
            // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã—ã¦ã„ãŸå ´åˆã€ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’å¾©å…ƒ
            if (isEditorFocused) {
              // æ–°ã—ã„ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®é•·ã•ã‚’è¶…ãˆãªã„ã‚ˆã†ã«ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’èª¿æ•´
              const newLength = j.content.length;
              cursorStart = Math.min(cursorStart, newLength);
              cursorEnd = Math.min(cursorEnd, newLength);
              
              // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’å¾©å…ƒ
              editor.setSelectionRange(cursorStart, cursorEnd);
              editor.focus(); // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚’ç¶­æŒ
            }
            
            status.className = "badge bg-warning text-dark";
            status.textContent = "Updated by others";
          }
          lastStamp = j.updated_at;
          contentAtLastSync = j.content;
        } else {
          // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ãŒåŒã˜ã§ã‚‚å¿µã®ãŸã‚ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’æ›´æ–°
          if (status.textContent === "Syncingâ€¦" || status.textContent.includes("error") || status.textContent.includes("Conflict")) {
            status.className = "badge bg-success";
            status.textContent = "Up-to-date";
          }
        }
      })
      .catch(() => {
        status.className = "badge bg-danger";
        status.textContent = "Sync error";
      });
  }
  
  // é©å¿œçš„ãƒãƒ¼ãƒªãƒ³ã‚°é–‹å§‹
  adaptivePolling();
</script>
{% endblock %}
