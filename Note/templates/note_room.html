{% extends "note_layout.html" %}

{% block meta_robots %}noindex, nofollow{% endblock %}
{% block meta_googlebot %}noindex, nofollow{% endblock %}

{% block page_title %}ノートルーム {{ room_id }} | FS!QR Note - リアルタイム共同編集{% endblock %}

{% block meta_description %}FS!QR Noteのリアルタイム共同編集ノートルーム。複数人でオンラインノートを同時編集・共有。リアルタイムでテキストが同期される協業ノートツール。{% endblock %}

{% block meta_keywords %}ノートルーム, リアルタイム共同編集, オンラインノート, 同時編集, 協業ツール, 共有ノート, FS QR Note{% endblock %}

{% block og_title %}ノートルーム {{ room_id }} | FS!QR Note - リアルタイム共同編集{% endblock %}

{% block og_description %}FS!QR Noteのリアルタイム共同編集ノートルーム。複数人でオンラインノートを同時編集・共有。リアルタイムでテキストが同期される協業ノートツール。{% endblock %}

{% block twitter_title %}ノートルーム {{ room_id }} | FS!QR Note{% endblock %}

{% block twitter_description %}リアルタイム共同編集ノートルーム。複数人でオンラインノートを同時編集・共有できます。{% endblock %}

{% block contents %}

<style>
/* Override colors for Note room to match create/search pages */
.modern-card-header {
  background: linear-gradient(135deg, rgb(132, 204, 22) 0%, rgb(163, 230, 53) 100%) !important;
}

.room-info-header {
  background: linear-gradient(135deg, rgb(132, 204, 22) 0%, rgb(163, 230, 53) 100%) !important;
}

.usage-section-header {
  background: linear-gradient(135deg, rgb(132, 204, 22) 0%, rgb(163, 230, 53) 100%) !important;
}

.usage-section-header::after {
  border-top-color: rgb(163, 230, 53) !important;
}

.room-info-value.room-info-url {
  display: inline-flex;
  align-items: center;
  gap: 0.75rem;
  flex-wrap: wrap;
}

.room-info-url-link {
  color: inherit;
  text-decoration: none;
  word-break: break-all;
}

.room-info-url-link:hover,
.room-info-url-link:focus {
  color: inherit;
  text-decoration: none;
}

.copy-url-button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 2.5rem;
  height: 2.5rem;
  padding: 0;
  border-radius: 999px;
  border: none;
  background: linear-gradient(135deg, rgb(132, 204, 22) 0%, rgb(163, 230, 53) 100%);
  color: #fff;
  cursor: pointer;
  transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
}

.copy-url-button svg {
  width: 1.25rem;
  height: 1.25rem;
  flex: none;
}

.copy-url-button:hover,
.copy-url-button:focus-visible {
  transform: translateY(-1px);
  box-shadow: 0 10px 15px -8px rgba(132, 204, 22, 0.5);
}

.copy-url-button:active {
  transform: translateY(0);
}

.copy-url-button.copied {
  background: linear-gradient(135deg, #15803d 0%, #22c55e 100%);
}
</style>

<div class="modern-page-container">
    <div class="modern-content-card">
        <div class="modern-card-header">
            <h1>
                <span class="svg-icon svg-icon--xl svg-icon--with-text" aria-hidden="true">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                        <path fill-rule="evenodd" d="M5.625 1.5c-1.036 0-1.875.84-1.875 1.875v17.25c0 1.035.84 1.875 1.875 1.875h12.75c1.035 0 1.875-.84 1.875-1.875V12.75A3.75 3.75 0 0 0 16.5 9h-1.875a1.875 1.875 0 0 1-1.875-1.875V5.25A3.75 3.75 0 0 0 9 1.5H5.625ZM7.5 15a.75.75 0 0 1 .75-.75h7.5a.75.75 0 0 1 0 1.5h-7.5A.75.75 0 0 1 7.5 15Zm.75 2.25a.75.75 0 0 0 0 1.5H12a.75.75 0 0 0 0-1.5H8.25Z" clip-rule="evenodd"/>
                        <path d="M12.971 1.816A5.23 5.23 0 0 1 14.25 5.25v1.875c0 .207.168.375.375.375H16.5a5.23 5.23 0 0 1 3.434 1.279 9.768 9.768 0 0 0-6.963-6.963Z"/>
                    </svg>
                </span>
                リアルタイムノート
            </h1>
        </div>
        
        <div class="modern-card-body">
            <!-- Room Info + QR Code -->
            <div class="room-info-container">
                <div class="room-info-card">
                    <div class="room-info-header">Room情報</div>
                    <div class="room-info-body">
                        <div class="room-info-row">
                            <span class="room-info-label">Room ID</span>
                            <span class="room-info-value">{{ room_id }}</span>
                        </div>
                        <div class="room-info-row">
                            <span class="room-info-label">Password</span>
                            <span class="room-info-value">{{ password }}</span>
                        </div>
                        <div class="room-info-row">
                            <span class="room-info-label">URL</span>
                            <span class="room-info-value room-info-url">
                                <a id="noteRoomUrl" class="room-info-url-link" href="{{ url_for('note.note_room', room_id=room_id, password=password, _external=True) }}" target="_blank" rel="noopener">
                                    {{ url_for('note.note_room', room_id=room_id, password=password, _external=True) }}
                                </a>
                                <button
                                  type="button"
                                  class="copy-url-button"
                                  data-copy-target="noteRoomUrl"
                                  data-default-label="URLをコピー"
                                  data-copied-label="コピー済み"
                                  aria-label="URLをコピー"
                                  title="URLをコピー"
                                >
                                  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-hidden="true">
                                    <path fill="currentColor" d="M16 1H4a2 2 0 0 0-2 2v12h2V3h12V1Zm4 4H8a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2Zm0 16H8V7h12v14Z"/>
                                  </svg>
                                </button>
                            </span>
                        </div>
                        <div class="room-info-row">
                            <span class="room-info-label">削除予定日</span>
                            <span class="room-info-value">
                                {% if deletion_date %}
                                    {{ deletion_date }} （{{ retention_days }}日後）
                                {% else %}
                                    {{ retention_days }}日後に自動削除
                                {% endif %}
                            </span>
                        </div>
                    </div>
                </div>
                
                <div class="qr-code-container">
                    <img src="https://api.qrserver.com/v1/create-qr-code?size=200x200&data={{ url_for('note.note_room', room_id=room_id, password=password, _external=True)|urlencode }}"
                         alt="QR Code" style="width: 160px; height: 160px;">
                </div>
            </div>

            <!-- Editor -->
            <div class="modern-form-group">
                <label for="editor" class="modern-form-label">共有ノート（最大5000文字）</label>
                <textarea id="editor" class="modern-editor"
                          placeholder="ここに入力すると1秒ごとに同期されます…"
                          maxlength="5000" style="height: 60vh;"></textarea>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 0.5rem;">
                    <small style="color: var(--text-medium);">リアルタイムで同期・保存されます</small>
                    <span id="status" class="badge bg-secondary" style="padding: 0.5rem 1rem; border-radius: 20px;">Syncing…</span>
                </div>
            </div>
        </div>
    </div>


<div class="usage-section">
  <div class="usage-section-header">
    <h5>使い方</h5>
  </div>
  <div class="usage-section-content">
    <p>
      このルームではテキストをリアルタイムに共有できます。<br>
      上記のIDとパスワード、URL、またはQRコードを共有すると他の参加者も同じノートを編集できます。<br>
      エディタに入力すると1秒ごとに自動保存・同期され、変更はすぐに反映されます。<br>
      最大5000文字まで入力可能です。
    </p>
  </div>
</div>

<script>
  async function copyTextToClipboard(text) {
    if (navigator.clipboard && window.isSecureContext) {
      return navigator.clipboard.writeText(text);
    }

    return new Promise((resolve, reject) => {
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.style.position = 'fixed';
      textarea.style.opacity = '0';
      document.body.appendChild(textarea);
      textarea.focus();
      textarea.select();

      try {
        if (document.execCommand('copy')) {
          resolve();
        } else {
          reject(new Error('execCommand failed'));
        }
      } catch (err) {
        reject(err);
      } finally {
        document.body.removeChild(textarea);
      }
    });
  }

  document.addEventListener('DOMContentLoaded', function () {
    document.querySelectorAll('.copy-url-button').forEach((button) => {
      button.addEventListener('click', async () => {
        const targetId = button.getAttribute('data-copy-target');
        const target = targetId ? document.getElementById(targetId) : null;
        if (!target) {
          return;
        }

        const text = target.textContent.trim();
        const defaultLabel = button.getAttribute('data-default-label') || 'コピー';
        const copiedLabel = button.getAttribute('data-copied-label') || 'コピー済み';
        if (!button.hasAttribute('aria-label')) {
          button.setAttribute('aria-label', defaultLabel);
        }
        if (!button.hasAttribute('title')) {
          button.setAttribute('title', defaultLabel);
        }

        try {
          await copyTextToClipboard(text);
          button.classList.add('copied');
          button.setAttribute('aria-label', copiedLabel);
          button.setAttribute('title', copiedLabel);
          setTimeout(() => {
            button.classList.remove('copied');
            button.setAttribute('aria-label', defaultLabel);
            button.setAttribute('title', defaultLabel);
          }, 2000);
        } catch (error) {
          alert('コピーに失敗しました。URLを選択して手動でコピーしてください。');
        }
      });
    });
  });
</script>
<script>
  const room   = "{{ room_id }}";
  const roomPassword = "{{ password }}";
  const editor = document.getElementById("editor");
  const status = document.getElementById("status");
  let lastStamp = "", selfEdit = false;
  let contentAtLastSync = "";  // <--- 追加: 最後に同期した時点のコンテンツ
  let selfEditTimeout = null; // selfEdit フラグのタイムアウト管理

  /* 最大文字数（サーバー側と合わせること） */
  const MAX_LENGTH = 5000;  // 追加: フロント側の最大文字数
  
  // selfEdit フラグの安全な設定関数
  function setSelfEdit(value, timeoutMs = 8000) {
    selfEdit = value;
    
    if (selfEditTimeout) {
      clearTimeout(selfEditTimeout);
      selfEditTimeout = null;
    }
    
    if (value && timeoutMs > 0) {
      // selfEdit が長時間 true のままにならないよう安全装置
      selfEditTimeout = setTimeout(() => {
        if (selfEdit) {
          console.warn("selfEdit flag was stuck, resetting");
          selfEdit = false;
          status.className = "badge bg-warning";
          status.textContent = "Connection timeout";
        }
      }, timeoutMs);
    }
  }

  // カーソル位置が安全に復元できるかチェックする関数
  function isCursorSafeToRestore(oldContent, newContent, cursorStart, cursorEnd) {
    // 基本的な安全チェック
    if (cursorStart < 0 || cursorEnd < 0 || cursorStart > cursorEnd) {
      return false;
    }
    
    // コンテンツの長さが大幅に変わった場合は復元しない
    const lengthDiff = Math.abs(newContent.length - oldContent.length);
    const relativeDiff = lengthDiff / Math.max(oldContent.length, 1);
    if (relativeDiff > 0.3) { // 30%以上の変化は復元しない
      return false;
    }
    
    // カーソル周辺のコンテンツが変更されているかチェック
    const contextRange = 50; // カーソル前後50文字の範囲をチェック
    const contextStart = Math.max(0, cursorStart - contextRange);
    const contextEnd = Math.min(oldContent.length, cursorEnd + contextRange);
    
    const oldContext = oldContent.substring(contextStart, contextEnd);
    const newContextEnd = Math.min(newContent.length, contextEnd);
    const newContext = newContent.substring(contextStart, newContextEnd);
    
    // コンテキストが大幅に変更されている場合は復元しない
    return oldContext === newContext || lengthDiff < 10;
  }

  /* 初回ロード */
  fetch(`/api/note/${room}/${roomPassword}`).then(r => r.json()).then(j => {
    editor.value = j.content;
    contentAtLastSync = j.content;  // <--- 追加
    lastStamp = j.updated_at;
    status.className = "badge bg-success";
    status.textContent = "Up-to-date";
  });

  /* 入力→POST(500ms) - 改善: デバウンス時間を延長してコンフリクト削減 */
  let typTimer;
  let saveRetryTimer;
  let retryCount = 0;
  const MAX_RETRIES = 3;
  
  // 保存処理を実行する関数（リトライ機能付き）
  function performSave(currentContent, isRetry = false) {
    // 文字数チェック
    if (currentContent.length > MAX_LENGTH) {
      alert(`文字数は最大 ${MAX_LENGTH} 文字までです。現在 ${currentContent.length} 文字です。`);
      setSelfEdit(false);
      return;
    }

    // 変更がない場合は保存をスキップ
    if (currentContent === contentAtLastSync) {
      setSelfEdit(false);
      return;
    }

    if (!isRetry) {
      retryCount = 0;
      setSelfEdit(true, 12000); // 12秒のタイムアウト設定（短縮）
      status.className = "badge bg-secondary";
      status.textContent = "Saving...";
    }

    fetch(`/api/note/${room}/${roomPassword}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        content: currentContent,
        last_known_updated_at: lastStamp,
        original_content: contentAtLastSync
      })
    })
    .then(r => {
      if (!r.ok) {
        return r.json().then(err => {
          throw new Error(err.error || "Save error");
        });
      }
      return r.json();
    })
    .then(j => {
      retryCount = 0; // 成功したらリトライカウントをリセット
      
      if (j.status && (j.status.startsWith("ok") || j.status.startsWith("conflict"))) {
        lastStamp = j.updated_at;
        if (j.content !== undefined && editor.value !== j.content) {
          // サーバーから新しいコンテントが返された場合の改善されたカーソル位置保持処理
          const cursorStart = editor.selectionStart;
          const cursorEnd = editor.selectionEnd;
          const isEditorFocused = document.activeElement === editor;
          const oldContent = editor.value;
          
          editor.value = j.content;
          
          // エディタにフォーカスがあり、カーソル位置が安全に復元できる場合のみ復元
          if (isEditorFocused && isCursorSafeToRestore(oldContent, j.content, cursorStart, cursorEnd)) {
            const newLength = j.content.length;
            const adjustedStart = Math.min(cursorStart, newLength);
            const adjustedEnd = Math.min(cursorEnd, newLength);
            editor.setSelectionRange(adjustedStart, adjustedEnd);
          }
        }
        contentAtLastSync = editor.value;
        
        status.className = "badge bg-success";
        status.textContent = "Saved";
        if (j.status === "ok_merged") {
          status.className = "badge bg-info";
          status.textContent = "Saved (Merged)";
        } else if (j.status === "conflict_merge_failed" || j.status === "conflict_during_merge_save" || j.status === "conflict") {
          status.className = "badge bg-warning text-dark";
          status.textContent = "Conflict resolved";
        }
      } else if (j.error) {
        status.className = "badge bg-danger";
        status.textContent = j.error;
      }
      setSelfEdit(false);
    })
    .catch(err => {
      // エラー時のリトライ処理
      if (retryCount < MAX_RETRIES && !err.message.includes("exceeds max length")) {
        retryCount++;
        status.className = "badge bg-warning";
        status.textContent = `Retrying... (${retryCount}/${MAX_RETRIES})`;
        
        // 指数バックオフでリトライ
        const retryDelay = Math.min(1000 * Math.pow(2, retryCount - 1), 5000);
        saveRetryTimer = setTimeout(() => {
          performSave(currentContent, true);
        }, retryDelay);
      } else {
        status.className = "badge bg-danger";
        status.textContent = err.message || "Save failed";
        setSelfEdit(false);
      }
    });
  }

  editor.addEventListener("input", () => {
    clearTimeout(typTimer);
    clearTimeout(saveRetryTimer); // 既存のリトライをキャンセル
    
    typTimer = setTimeout(() => {
      const currentContent = editor.value;
      performSave(currentContent);
    }, 800); // デバウンス時間を800msに延長（競合を更に削減）
  });

  /* 適応的ポーリング - アクティブ編集中は頻度を下げる */
  let lastActivity = Date.now();
  let pollingInterval = 1500; // 基本ポーリング間隔を少し長く
  let lastPollingTime = Date.now();
  
  // アクティビティ検出のためのイベントリスナー
  editor.addEventListener("focus", () => {
    lastActivity = Date.now();
  });
  
  editor.addEventListener("keydown", () => {
    lastActivity = Date.now();
  });
  
  // マウスクリックもアクティビティとして検出
  editor.addEventListener("click", () => {
    lastActivity = Date.now();
  });
  
  function adaptivePolling() {
    const now = Date.now();
    const timeSinceActivity = now - lastActivity;
    const timeSinceLastPoll = now - lastPollingTime;
    
    // 最近編集活動があった場合はポーリング頻度を下げる
    if (timeSinceActivity < 7000) { // 7秒以内に活動があった（延長）
      pollingInterval = 3000; // 3秒間隔に延長
    } else if (timeSinceActivity < 15000) { // 15秒以内
      pollingInterval = 2000; // 2秒間隔
    } else {
      pollingInterval = 1500; // 通常の1.5秒間隔
    }
    
    // ポーリング実行の判定
    if (timeSinceLastPoll >= pollingInterval) {
      lastPollingTime = now;
      performPolling();
    }
    
    // 次回ポーリング予約（150ms間隔でチェック、負荷軽減）
    setTimeout(adaptivePolling, 150);
  }
  
  function performPolling() {
    if (selfEdit) return; // 自分編集中はポーリングしない
    
    // ユーザーが現在フォーカスしているかチェック
    const isEditorFocused = document.activeElement === editor;
    
    fetch(`/api/note/${room}/${roomPassword}`)
      .then(r => r.json())
      .then(j => {
        if (j.updated_at !== lastStamp) {
          if (!selfEdit) {
            // ユーザーがエディターにフォーカスしている場合、カーソル位置を保存
            let cursorStart = 0;
            let cursorEnd = 0;
            const oldContent = editor.value;
            
            if (isEditorFocused) {
              cursorStart = editor.selectionStart;
              cursorEnd = editor.selectionEnd;
            }
            
            // コンテンツを更新
            editor.value = j.content;
            
            // ユーザーがフォーカスしていて、安全に復元できる場合のみカーソル位置を復元
            if (isEditorFocused && isCursorSafeToRestore(oldContent, j.content, cursorStart, cursorEnd)) {
              // 新しいコンテンツの長さを超えないようにカーソル位置を調整
              const newLength = j.content.length;
              cursorStart = Math.min(cursorStart, newLength);
              cursorEnd = Math.min(cursorEnd, newLength);
              
              // カーソル位置を復元
              editor.setSelectionRange(cursorStart, cursorEnd);
              editor.focus(); // フォーカスを維持
            }
            
            status.className = "badge bg-warning text-dark";
            status.textContent = "Updated by others";
          }
          lastStamp = j.updated_at;
          contentAtLastSync = j.content;
        } else {
          // タイムスタンプが同じでも念のためステータスを更新
          if (status.textContent === "Syncing…" || status.textContent.includes("error") || status.textContent.includes("Conflict")) {
            status.className = "badge bg-success";
            status.textContent = "Up-to-date";
          }
        }
      })
      .catch(() => {
        status.className = "badge bg-danger";
        status.textContent = "Sync error";
      });
  }
  
  // 適応的ポーリング開始
  adaptivePolling();
</script>
{% endblock %}
